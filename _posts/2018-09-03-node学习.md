---
layout: post
title:  "node学习(1)"
date:   2018-09-03 23:31:01 +0800
categories: js
tag: node
---

* content
{:toc}


buffer 缓冲			{#buffer}
====================================

Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。  

Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。 

Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require('buffer').Buffer。 

类方法							{#buffer_method}
------------------------------------
  
```javascript
Buffer.alloc(size[, fill[, encoding]]) //分配一个大小为 size 字节的新建的 Buffer  
Buffer.allocUnsafe(size) //以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。  
Buffer.from(array)  
Buffer.from(string[, encoding])
Buffer.compare(buf1, buf2)
Buffer.concat(list[, totalLength])
```

类属性							{#buffer_attr}
------------------------------------

```javascript
buf.fill(value[, offset[, end]][, encoding])
buf.includes(value[, byteOffset][, encoding])
buf.length
buf.toJSON()
buf.toString([encoding[, start[, end]]])
buf.write(string[, offset[, length]][, encoding])
buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]]) // 拷贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠,注意变化的是 target
```

UTF-8							{#utf_8}
------------------------------------

> UTF-8 的编码规则很简单：如果只有一个字节，那么最高的比特位为 0；如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。
具体的表现形式为：
0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的；
110xxxxx 10xxxxxx：双字节编码形式；
1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式；
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式。


buffer的中文乱码问题							{#buffer_error}
------------------------------------

```javascript
// testdata.md 为中文
var fs = require('fs');
var rs = fs.createReadStream('testdata.md', {highWaterMark: 11}); // 乱码 
//var rs = fs.createReadStream('testdata.md', {encoding:'utf-8',highWaterMark: 11}); // 无乱码
var data = '';
rs.on("data", function (trunk){
    data += trunk; 
});
rs.on("end", function () { 
    console.log(data);
});
```
>通过string_decoder对象输出第一个截取Buffer(事件循xx)时，只返回事 件循这个字符串，保留xx。第二次通过string_decoder对象输出时检测到上次保 留的xx，将上次剩余内容和本次的Buffer进行重新拼接输出。于是达到正常输出 的目的。  
string_decoder，目前在文件流读取和网络流读取中都有应用到，一定程度上避 免了粗鲁拼接trunk导致的乱码错误。但是，遗憾在于string_decoder目前只支 持utf8编码。它的思路其实还可以扩展到其他编码上，只是最终是否会支持目前 尚不可得知.  

连接Buffer对象的正确方法：  

```javascript
var fs = require('fs');
var iconv = require('iconv-lite');
var rs = fs.createReadStream('testdata.md');
var chunks = [];
var size = 0;
rs.on('data', function(chunk){
    chunks.push(chunk);
    size += chunk.length;
})
rs.on('end', function(){
    var buf = Buffer.concat(chunks, size);
    var str = iconv.decode(buf, 'utf-8');
    console.log(str);
});
```
>正确的拼接方法是用一个数组来存储接收到的所有的Buffer片段并记录下所有片段的总长度，然后用Buffer.concat()方法生成一个合并的Buffer对象。Buffer.concat()方法封装了从小Buffer对象到大Buffer对象的复制过程。  

Buffer.concat： 代码注释来源 [ Nodejs源码解析之Buffer](https://blog.csdn.net/leoleocs/article/details/50384982)   

```javascript
// 相当于把Buffer数组中的内容，拼接起来。
// 特别注意的是，如果只有一个对象做拼接的时候，是不新创建对象的。
// 函数没有检查数组对象中的类型。
Buffer.concat = function(list, length) {
   // 首先检查第一个参数list是否为数组，如果不是，直接报错。
  if (!util.isArray(list))
    throw new TypeError('list argument must be an Array of Buffers.');
   // 检查第二个参数length是否传入，
  if (util.isUndefined(length)) {
     //处理没有传入的情况
    //没有传入的情况下，处理成当前数组所有Buffer对象长度的总和
    length = 0;
    for (var i = 0; i < list.length; i++)
      length += list[i].length;
  } else {
    // 已经传入，直接确保是uint32的值
    length = length >>> 0;
  }
  // 如果数组的长度为0，直接返回长度为0的buffer对象
  if (list.length === 0)
    return new Buffer(0);
  else if (list.length === 1)
    //如果长度为1，直接返回的是第一个对象
    return list[0];

  // 否则需要新创建对象，将buffer对象拼接起来。
  var buffer = new Buffer(length);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    // 拷贝对象内容到新的buffer对象中。
    // copy的定义在node_buffer.cc中，使用memmove实现
    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};
``` 



child_process - 子进程		{#child_process}
====================================

child_process 模块提供了衍生子进程的功能，它与 popen(3) 类似，但不完全相同。 这个功能主要由 child_process.spawn() 函数提供：  

```javascript
const { spawn } = require('child_process');
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
  console.log(`输出：${data}`);
});

ls.stderr.on('data', (data) => {
  console.log(`错误：${data}`);
});

ls.on('close', (code) => {
  console.log(`子进程退出码：${code}`);
});
```
默认情况下，Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。 数据能以非阻塞的方式在管道中流通。 有些程序会在内部使用行缓冲 I/O，虽然这并不影响 Node.js，但发送到子进程的数据可能无法被立即使用。  

导出方法							{#child_process_attr}
------------------------------------

```javascript
child_process.exec(command[, options][, callback])
child_process.execFile(file[, args][, options][, callback])
child_process.fork(modulePath[, args][, options])
child_process.spawn(command[, args][, options])
child_process.execFileSync(file[, args][, options])
child_process.execSync(command[, options])
child_process.spawnSync(command[, args][, options])
```

ChildProcess 类                 {#ChildProcess}
------------------------------------

ChildProcess 类的实例是 EventEmitter，代表衍生的子进程。  
ChildProcess 的实例不被直接创建。 而是，使用 child_process.spawn()、child_process.exec()、child_process.execFile() 或 child_process.fork() 方法创建 ChildProcess 实例。  

>child_process模块提供了一个ChildProcess的新类，它可以作为从父进程访问子进程的表示形式。Process模块也是ChildProcess对象。当你从父模块访问process时，它是父ChildProcess对象，当你从子进程访问Process时，它是子ChildProcess对象

+ 1.事件：  

```javascript
// 'close' 事件
// 'disconnect' 事件
// 'error' 事件
// 'exit' 事件
// 'message' 事件

const { spawn } = require('child_process');
const grep = spawn('grep', ['ssh']);

grep.on('close', (code, signal) => {
  console.log(`子进程收到信号 ${signal} 而终止`);
});

// 发送 SIGHUP 到进程
grep.kill('SIGHUP');
```

+ 2.属性和方法：  

```javascript
subprocess.connected // #表明是否仍可以从一个子进程发送和接收消息
subprocess.stderr // <stream.Readable>一个代表子进程的 stderr 的可读流。
subprocess.stdin // <stream.Writable> 一个代表子进程的 stdin 的可写流
subprocess.stdout // <stream.Readable> 一个代表子进程的 stdout 的可读流。

subprocess.disconnect() // 关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。
subprocess.kill([signal])
subprocess.send(message[, sendHandle[, options]][, callback])
```
>当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 child_process.fork()），subprocess.send() 方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 [process.on('message')] 事件接收。  
注意: 消息通过序列化和解析进行传递，结果就是消息可能跟开始发送的不完全一样。  

```javascript
// 例子，父进程脚本如下：
const cp = require('child_process');
const n = cp.fork(`${__dirname}/sub.js`);
n.on('message', (m) => {
  console.log('PARENT got message: ', m);
});
// Causes the child to print: CHILD got message: { hello: 'world' }
n.send({ hello: 'world' });


//然后是子进程脚本，'sub.js' 可能看上去像这样：
process.on('message', (m) => {
  console.log('CHILD got message:', m);
});
// Causes the parent to print: PARENT got message: { foo: 'bar', baz: null }
process.send({ foo: 'bar', baz: NaN });
```

发送句柄：  
sendHandle 参数可用于将一个 TCP server 对象句柄传给子进程;  
当服务器在父进程和子进程之间是共享的，则一些连接可被父进程处理，另一些可被子进程处理.  

```javascript
const subprocess = require('child_process').fork('subprocess.js');

// 开启 server 对象，并发送该句柄。
const server = require('net').createServer();
server.on('connection', (socket) => {
  socket.end('被父进程处理');
});
server.listen(1337, () => {
  subprocess.send('server', server);
});

// 子进程接收 server 对象如下：
process.on('message', (m, server) => {
  if (m === 'server') {
    server.on('connection', (socket) => {
      socket.end('被子进程处理');
    });
  }
});
```


cluster (集群)		{#cluster}
====================================

cluster 模块允许简单容易的创建共享服务器端口的子进程。

```javascript
// 官网实现方式
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`主进程 ${process.pid} 正在运行`);

  // 衍生工作进程。
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
  });
} else {
  // 工作进程可以共享任何 TCP 连接。
  // 在本例子中，共享的是一个 HTTP 服务器。
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('你好世界\n');
  }).listen(8000);

  console.log(`工作进程 ${process.pid} 已启动`);
}
```
另外一种更优雅的实现方式:  

```javascript
const cluster = require('cluster');
cluster.setupMaster({
    exec: "cluster_worker.js"
});

var cpus = require('os').cpus();
for(var i=0; i<cpus.length; i++){
    cluster.fork();
}
```

```javascript
// cluster_worker.js
var http = require('http');

http.createServer((req, res) => {
    res.writeHead(200);
    res.end('你好世界\n');
  }).listen(8000);

console.log(`工作进程 ${process.pid} 已启动`);
```


Class: Worker                 {#cluster_worker}
------------------------------------

Worker对象包含了关于工作进程的所有public信息和方法。  
在一个主进程里，可以使用cluster.workers来获取Worker对象。  
在一个工作进程里，可以使用cluster.worker来获取Worker对象。  

```javascript
// Event: 'disconnect'
// Event: 'error'
// Event: 'exit'
// Event: 'listening'
// Event: 'message'


const cluster = require('cluster');
const http = require('http');

if (cluster.isMaster) {

  // 跟踪 http 请求
  let numReqs = 0;
  setInterval(() => {
    console.log(`numReqs = ${numReqs}`);
  }, 1000);

  // 计算请求数目
  function messageHandler(msg) {
    if (msg.cmd && msg.cmd === 'notifyRequest') {
      numReqs += 1;
    }
  }

  // 启动 worker 并监听包含 notifyRequest 的消息
  const numCPUs = require('os').cpus().length;
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  for (const id in cluster.workers) {
    cluster.workers[id].on('message', messageHandler);
  }

} else {

  // Worker 进程有一个http服务器
  http.Server((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');

    // 通知 master 进程接收到了请求
    process.send({ cmd: 'notifyRequest' });
  }).listen(8000);
}
```

console (控制台)		{#console}
====================================

console 模块提供了一个简单的调试控制台，类似于 Web 浏览器提供的 JavaScript 控制台。  

该模块导出了两个特定的组件：

一个 Console 类，包含 console.log() 、 console.error() 和 console.warn() 等方法，可以被用于写入到任何 Node.js 流。  
一个全局的 console 实例，可被用于写入到 process.stdout 和 process.stderr。 全局的 console 使用时无需调用 require('console')。  
注意：全局的 console 对象的方法既不总是同步的（如浏览器中类似的 API），也不总是异步的（如其他 Node.js 流）。 详见 进程 I/O。  

Console 类                 {#console_Console}
------------------------------------

Console 类可用于创建一个具有可配置的输出流的简单记录器，可以通过 require('console').Console 或 console.Console 使用：  
```javascript
const { Console } = require('console');
const { Console } = console;
```

```javascript
// new Console(stdout[, stderr][, ignoreErrors])#
// new Console(options)
const output = fs.createWriteStream('./stdout.log');
const errorOutput = fs.createWriteStream('./stderr.log');
// custom simple logger
const logger = new Console({ stdout: output, stderr: errorOutput });
// use it like console
const count = 5;
logger.log('count: %d', count);
// in stdout.log: count 5
```
>用一个或两个输出流实例创建一个新的 Console。 输出流 stdout 用来记录日志和信息；stderr 用来记录警告和错误。如果不提供 stderr，则 stdout 会被用作 stderr。全局符号 console 是一个特殊的 Console 实例，其输出会被送往 process.stdout 和 process.stderr。它等价于调用：`new Console({ stdout: process.stdout, stderr: process.stderr });`






